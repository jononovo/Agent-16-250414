import { 
  EnhancedNodeExecutor, 
  NodeExecutionData,
  WorkflowItem,
  createWorkflowItem 
} from '../types/workflow';
import { createEnhancedNodeExecutor } from '../enhancedWorkflowEngine';

interface ClaudeNodeData {
  model?: string;
  systemPrompt?: string;
  userPrompt?: string;
  apiKey?: string;
  settings?: {
    apiKey?: string;
    model?: string;
    temperature?: number;
    maxTokens?: number;
  };
  [key: string]: any;
}

/**
 * Claude Node Definition
 */
const claudeDefinition = {
  type: 'claude',
  displayName: 'Claude AI',
  description: 'Generate text using Anthropic Claude AI',
  icon: 'Bot',
  category: 'ai',
  version: '1.0',
  
  // Define the input parameters
  inputs: {
    input: {
      type: 'string' as const,
      displayName: 'Input Text',
      description: 'Text input to include in the prompt',
      required: false
    },
    systemPrompt: {
      type: 'string' as const,
      displayName: 'System Prompt',
      description: 'System instructions for Claude',
      required: false
    },
    userPrompt: {
      type: 'string' as const,
      displayName: 'User Prompt',
      description: 'User prompt template (input will be appended)',
      required: false
    },
    model: {
      type: 'string' as const,
      displayName: 'Model',
      description: 'Claude model to use',
      required: false,
      default: 'claude-3-opus-20240229'
    },
    temperature: {
      type: 'number' as const, 
      displayName: 'Temperature',
      description: 'Controls randomness (0-1)',
      required: false,
      default: 0.7
    },
    maxTokens: {
      type: 'number' as const,
      displayName: 'Max Tokens',
      description: 'Maximum number of tokens to generate',
      required: false,
      default: 4096
    },
    apiKey: {
      type: 'string' as const,
      displayName: 'API Key',
      description: 'Anthropic API key',
      required: false
    }
  },
  
  // Define the outputs
  outputs: {
    default: {
      type: 'string' as const,
      displayName: 'Generated Text',
      description: 'Text generated by Claude'
    },
    complete: {
      type: 'object' as const,
      displayName: 'Complete Response',
      description: 'Complete Claude API response'
    }
  }
};

/**
 * Extract text input from NodeExecutionData
 */
function extractTextFromInput(input: NodeExecutionData): string {
  if (!input.items || input.items.length === 0) {
    return '';
  }
  
  const item = input.items[0];
  
  // Handle different data formats
  if (typeof item.json === 'string') {
    return item.json;
  }
  
  if (typeof item.json.data === 'string') {
    return item.json.data;
  }
  
  if (typeof item.json.text === 'string') {
    return item.json.text;
  }
  
  if (typeof item.json.content === 'string') {
    return item.json.content;
  }
  
  // Convert to string if it's an object
  if (typeof item.json === 'object' && item.json !== null) {
    try {
      return JSON.stringify(item.json, null, 2);
    } catch (e) {
      return '';
    }
  }
  
  return '';
}

/**
 * Simulates Claude response when no API key is available
 */
function simulateClaudeResponse(model: string, systemPrompt: string, userPrompt: string): {
  id: string;
  content: string;
  model: string;
  usage: { input_tokens: number; output_tokens: number };
} {
  const timestamp = new Date().toISOString();
  const id = `msg_sim_${Math.random().toString(36).substring(2, 10)}`;
  
  // Generate a simulated response based on the prompt
  const simulatedContent = `This is a simulated response from Claude (${model}), 
as no API key was provided. In a real scenario, I would respond to:

${userPrompt}

With the system context:
${systemPrompt || '(No system prompt provided)'}

To get real responses, please provide a valid Anthropic API key.`;

  return {
    id,
    content: simulatedContent,
    model,
    usage: {
      input_tokens: Math.floor((systemPrompt.length + userPrompt.length) / 4),
      output_tokens: Math.floor(simulatedContent.length / 4)
    }
  };
}

/**
 * Executor for Claude AI nodes
 */
export const claudeExecutor: EnhancedNodeExecutor = createEnhancedNodeExecutor(
  claudeDefinition,
  async (nodeData: ClaudeNodeData, inputs: Record<string, NodeExecutionData>): Promise<NodeExecutionData> => {
    // Get settings from node data (either direct or from settings object)
    const settings = nodeData.settings || {};
    const model = nodeData.model || settings.model || 'claude-3-opus-20240229';
    const temperature = settings.temperature !== undefined ? settings.temperature : 0.7;
    const maxTokens = settings.maxTokens !== undefined ? settings.maxTokens : 4096;
    const apiKey = nodeData.apiKey || settings.apiKey || process.env.ANTHROPIC_API_KEY;
    
    // Get prompts from node data
    let systemPrompt = nodeData.systemPrompt || '';
    let userPrompt = nodeData.userPrompt || '';
    
    // Extract input text, if provided
    let inputText = '';
    if (inputs.input) {
      inputText = extractTextFromInput(inputs.input);
    }
    
    // Combine userPrompt with inputText if both are provided
    if (userPrompt && inputText) {
      userPrompt = `${userPrompt}\n\n${inputText}`;
    } else if (inputText) {
      userPrompt = inputText;
    }
    
    // Validate required parameters
    if (!userPrompt) {
      throw new Error('No user prompt or input text provided');
    }
    
    console.log(`Executing Claude node with model ${model} and ${userPrompt.length} chars of prompt`);
    
    try {
      // Prepare metadata
      const startTime = new Date();
      
      if (!apiKey) {
        console.log('No API key provided; generating simulated Claude response');
        const simulatedResponse = simulateClaudeResponse(model, systemPrompt, userPrompt);
        
        // Create workflow items for both outputs
        const textItem: WorkflowItem = {
          json: simulatedResponse.content,
          meta: {
            source: 'claude_simulation',
            timestamp: new Date(),
            outputType: 'default'
          }
        };
        
        const completeItem: WorkflowItem = {
          json: simulatedResponse,
          meta: {
            source: 'claude_simulation',
            timestamp: new Date(),
            outputType: 'complete'
          }
        };
        
        return {
          items: [textItem, completeItem],
          meta: {
            startTime,
            endTime: new Date(),
            itemsProcessed: 2,
            sourceOperation: 'claude',
            isSimulated: true
          }
        };
      } else {
        // Make actual API call to Claude
        const apiUrl = 'https://api.anthropic.com/v1/messages';
        
        let headers: HeadersInit = {
          'Content-Type': 'application/json',
          'x-api-key': apiKey,
          'anthropic-version': '2023-06-01'
        };
        
        // Prepare the request payload
        const requestBody = {
          model,
          max_tokens: maxTokens,
          temperature,
          system: systemPrompt || undefined,
          messages: [
            { role: 'user', content: userPrompt }
          ]
        };
        
        console.log('Sending request to Claude API');
        
        try {
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers,
            body: JSON.stringify(requestBody)
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Claude API error (${response.status}): ${errorText}`);
          }
          
          const result = await response.json();
          console.log('Claude API response received');
          
          // Extract content from response
          const content = result.content?.[0]?.text || '';
          
          // Create workflow items for both outputs
          const textItem: WorkflowItem = {
            json: content,
            meta: {
              source: 'claude_api',
              timestamp: new Date(),
              outputType: 'default'
            }
          };
          
          const completeItem: WorkflowItem = {
            json: result,
            meta: {
              source: 'claude_api',
              timestamp: new Date(),
              outputType: 'complete'
            }
          };
          
          return {
            items: [textItem, completeItem],
            meta: {
              startTime,
              endTime: new Date(),
              itemsProcessed: 2,
              sourceOperation: 'claude',
              apiKey: apiKey ? '[hidden]' : undefined,
              model,
              usage: result.usage
            }
          };
        } catch (apiError) {
          // Create an error item with context
          const errorItem: WorkflowItem = {
            json: {
              error: apiError instanceof Error ? apiError.message : String(apiError),
              context: {
                model,
                promptLength: userPrompt.length,
                systemPromptLength: systemPrompt.length
              }
            },
            meta: {
              source: 'claude_api_error',
              timestamp: new Date()
            }
          };
          
          return {
            items: [errorItem],
            meta: {
              startTime,
              endTime: new Date(),
              itemsProcessed: 0,
              sourceOperation: 'claude',
              error: apiError instanceof Error ? apiError.message : String(apiError)
            }
          };
        }
      }
    } catch (error) {
      // Handle any other errors
      console.error('Error in Claude executor:', error);
      throw new Error(`Claude execution error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
);